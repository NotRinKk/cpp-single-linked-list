# SingleLinkedList  

## Описание  
Этот проект реализует **односвязный список** на языке C++. В отличие от стандартного `std::list`, управление памятью осуществляется вручную с помощью **обычных указателей (`Node* next`)**, а не `std::unique_ptr`.  

## Методы  

Класс `SingleLinkedList<T>` предоставляет следующие методы:  

- **`PushFront(const T& value)`** – добавляет элемент в начало списка.  
- **`PopFront()`** – удаляет первый элемент списка.  
- **`Clear()`** – очищает список, освобождая всю занятую память.  
- **`Size() const`** – возвращает текущее количество элементов.  
- **`Empty() const`** – проверяет, пуст ли список.  
- **`begin()` / `end()`** – возвращает итераторы для работы с элементами.  

## Правило пяти  
Для корректного управления ресурсами класс `SingleLinkedList` реализует **правило пяти**:  
1. **Деструктор** – освобождает всю занятую память.  
2. **Конструктор копирования** – выполняет глубокое копирование списка.  
3. **Оператор присваивания** – удаляет текущие данные и копирует новые.  
4. **Конструктор перемещения** – переносит данные без копирования.  
5. **Оператор перемещающего присваивания** – очищает старые данные и переносит новые.  

Это гарантирует безопасность работы с динамической памятью и предотвращает утечки.  

## Используемые технологии  
- **C++17** – используется для удобства работы с шаблонами и итераторами.  
- **RAII (Resource Acquisition Is Initialization)** – автоматическое управление памятью в конструкторе и деструкторе.  
- **Итераторы** – реализованы для удобного перебора элементов в циклах `for-each`.  

## Алгоритмическая сложность  

| Операция       | Сложность |  
|---------------|-----------|  
| `PushFront`   | **O(1)**  |  
| `PopFront`    | **O(1)**  |  
| `Clear`       | **O(n)**  |  
| `Size`        | **O(1)**  |  
| `Empty`       | **O(1)**  |  
| Итерация по списку | **O(n)** |  

## Использование  

Пример работы со списком:  

```cpp
#include "single-linked-list.h"

int main() {
    SingleLinkedList<int> list;
    
    // Добавление элементов
    list.PushFront(30);
    list.PushFront(20);
    list.PushFront(10);
    
    // Итерация
    for (const auto& x : list) {
        std::cout << x << " ";  // 10 20 30
    }
    
    // Вставка после первого элемента
    auto it = list.begin();
    list.InsertAfter(it, 15);
    
    // Удаление первого элемента
    list.PopFront();
    
    return 0;
}
```
